.\" Copyright (C) 2000  Internet Software Consortium.
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
.\" DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
.\" INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
.\" INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
.\" FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
.\" NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
.\" WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.\" $Id: lwres_buffer.3,v 1.3 2000/08/01 01:20:26 tale Exp $
.\"
.Dd Jun 30, 2000
.Dt LWRES_BUFFER 3
.Os BIND9 9
.ds vT BIND9 Programmer's Manual
.Sh NAME
.Nm lwres_buffer_init ,
.Nm lwres_buffer_invalidate ,
.Nm lwres_buffer_add ,
.Nm lwres_buffer_subtract ,
.Nm lwres_buffer_clear ,
.Nm lwres_buffer_first ,
.Nm lwres_buffer_forward ,
.Nm lwres_buffer_back ,
.Nm lwres_buffer_getuint8 ,
.Nm lwres_buffer_putuint8 ,
.Nm lwres_buffer_getuint16 ,
.Nm lwres_buffer_putuint16 ,
.Nm lwres_buffer_getuint32 ,
.Nm lwres_buffer_putuint32 ,
.Nm lwres_buffer_putmem ,
.Nm lwres_buffer_getmem
.Nd lightweight resolver buffer management
.Sh SYNOPSIS
.Fd #include <lwres/lwbuffer.h>
.Fd
.Ft void
.Fo lwres_buffer_init
.Fa "lwres_buffer_t *b"
.Fa "void *base"
.Fa "unsigned int length"
.Fc
.Ft void
.Fo lwres_buffer_invalidate
.Fa "lwres_buffer_t *b"
.Fc
.Ft void
.Fo lwres_buffer_add
.Fa "lwres_buffer_t *b"
.Fa "unsigned int n"
.Fc
.Ft void
.Fo lwres_buffer_subtract
.Fa "lwres_buffer_t *b"
.Fa "unsigned int n"
.Fc
.Ft void
.Fo lwres_buffer_clear
.Fa "lwres_buffer_t *b"
.Fc
.Ft void
.Fo lwres_buffer_first
.Fa "lwres_buffer_t *b"
.Fc
.Ft void
.Fo lwres_buffer_forward
.Fa "lwres_buffer_t *b"
.Fa "unsigned int n"
.Fc
.Ft void
.Fo lwres_buffer_back
.Fa "lwres_buffer_t *b"
.Fa "unsigned int n"
.Fc
.Ft lwres_uint8_t
.Fo lwres_buffer_getuint8
.Fa "lwres_buffer_t *b"
.Fc
.Ft void
.Fo lwres_buffer_putuint8
.Fa "lwres_buffer_t *b"
.Fa "lwres_uint8_t val"
.Fc
.Ft lwres_uint16_t
.Fo lwres_buffer_getuint16
.Fa "lwres_buffer_t *b"
.Fc
.Ft void
.Fo lwres_buffer_putuint16
.Fa "lwres_buffer_t *b"
.Fa "lwres_uint16_t val"
.Fc
.Ft lwres_uint32_t
.Fo lwres_buffer_getuint32
.Fa "lwres_buffer_t *b"
.Fc
.Ft void
.Fo lwres_buffer_putuint32
.Fa "lwres_buffer_t *b"
.Fa "lwres_uint32_t val"
.Fc
.Ft void
.Fo lwres_buffer_putmem
.Fa "lwres_buffer_t *b"
.Fa "const unsigned char *base"
.Fa "unsigned int length"
.Fc
.Ft void
.Fo lwres_buffer_getmem
.Fa "lwres_buffer_t *b"
.Fa "unsigned char *base"
.Fa "unsigned int length"
.Fc
.Sh DESCRIPTION
These functions use the following structure as a buffer descriptor to
manage the actual storage:
.Bd -literal -offset indent
typedef struct lwres_buffer lwres_buffer_t;
struct lwres_buffer {
	unsigned int		magic;
	unsigned char 	       *base;
	/* The following integers are byte offsets from 'base'. */
	unsigned int		length;
	unsigned int		used;
	unsigned int 		current;
	unsigned int 		active;
};
.Ed
The main reason for making the buffer structure public is so that
buffer operations can be implemented using macros.
Applications should not manipulate this structure directly.
They should use the functions listed below.
.Pp
A buffer is a region of memory, together with a set of related
subregions.
The \*qused region\*q and the \*qavailable\*q region are disjoint, and
their union is the buffer's region.
The used region extends from the beginning of the buffer region to the
last used byte.
The available region extends from one byte greater than the last used
byte to the end of the  buffer's region.
The size of the used region can be changed using various
buffer commands.
Initially, the used region is empty.
.Pp
The used region is further subdivided into two disjoint regions: the
\*qconsumed region\*q and the \*qremaining region\*q.
The union of these two regions is the used region.
The consumed region extends from the beginning of the used region to
the byte before the \*qcurrent\*q offset (if any).
The \*qremaining\*q region the current pointer to the end of the used
region.
The size of the consumed region can be changed using various
buffer commands.
Initially, the consumed region is empty.
.Pp
The \*qactive region\*q is an (optional) subregion of the remaining
region.
It extends from the current offset to an offset in the
remaining region.
Initially, the active region is empty.
If the current offset advances beyond the chosen offset,
the active region will also be empty.
.Pp
Except for
.Fn lwres_buffer_init ,
all of the buffer managements functions contain an assertion check
that
.Fa b
is a pointer to a valid lightweight resolver buffer.
.Pp
.Fn lwres_buffer_init
makes the
.Dv "struct lwres_buffer"
referenced by
.Fa *b
to be associated with a memory region of size
.Fa length
bytes starting at location
.Fa base.
The function checks that
.Fa *b is not
.Dv NULL .
.Pp
The
.Dv lwres_buffer_t
.Fa *b
is invalidated by
.Fn lwres_buffer_invalidate .
.Fa *b
must be a valid lightweight resolver buffer.
.Pp
The functions
.Fn lwres_buffer_add
and
.Fn lwres_buffer_subtract
respectively increase and decrease the used space in
buffer
.Fa *b
by
.Fa n
bytes.
.Fa *b
.Fn lwres_buffer_add
checks for buffer overflow and
.Fn lwres_buffer_subtract
checks for underflow.
These functions do not allocate or deallocate memory.
They just change the value of
.Li b->used .
.Pp
A lightweight resolver buffer is re-initialised by
.Fn lwres_buffer_clear .
The function sets
.Li b->used ,
.Li b->current
and
.Li b->active
to zero.
.Pp
.Fn lwres_buffer_first
makes the consumed region of buffer
.Fa *p
empty by setting
.Li b->current
to zero: the start of the buffer.
.Pp
The consumed region of buffer
.Fa *b
is increased by
.Fa n
bytes
using
.Fn lwres_buffer_forward .
The function checks for buffer overflow.
Similarly,
.Fn lwres_buffer_back
decreases buffer
.Fa b 's
consumed region by
.Fa n
bytes and checks for buffer underflow.
.Pp
.Fn lwres_buffer_getuint8
reads an unsigned 8-bit integer from
.Fa *b
and returns it.
The function checks that it does not read past the end of the buffer's
consumed region.
.Fn lwres_buffer_putuint8
writes the unsigned 8-bit integer
.Fa val
to buffer
.Fa *b .
It checks that the buffer has available space for
.Fa val .
.Pp
.Fn lwres_buffer_getuint16
and
.Fn lwres_buffer_getuint32
are identical to
.Fn lwres_buffer_putuint8
except that they respectively read an unsigned 16-bit or 32-bit integer from
.Fa b
converting it from network byte order to host byte order before
returning its value.
Similarly,
.Fn lwres_buffer_putuint16
and
.Fn lwres_buffer_putuint32
writes the unsigned 16-bit or 32-bit integer
.Fa val
to buffer
.Fa b ,
converting it from host byte order to network byte order.
.Pp
Arbitrary amounts of data are read or written from a lightweight
resolver buffer with
.Fn lwres_buffer_getmem
and
.Fn lwres_buffer_putmem
respectively.
.Fn lwres_buffer_putmem
copies
.Fa length
bytes of memory at
.Fa base
to
.Fa b.
Conversely,
.Fn lwres_buffer_getmem
copies
.Fa length
bytes of memory from
.Fa b
to
.Fa base .
For both functions,
.Fa base
should point to at least
.Fa length
bytes of valid memory.
.Fa base
.Sh RETURN VALUES
.Fn lwres_buffer_getuint8 ,
.Fn lwres_buffer_getuint16
and
.Fn lwres_buffer_getuint32
return an 8-, 16- or 32-bit unsigned integer respectively from the
current offset in buffer
.Fa b .
The 16- and 32-bit quantities are presented in host byte order even
though they are stored in network byte order inside the buffer.
.Sh SEE ALSO
.Sh BUGS
Buffers have no synchronization.
Clients must ensure exclusive access for thread-safe operations.
